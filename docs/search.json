[{"path":"index.html","id":"home","chapter":"Home","heading":"Home","text":"","code":""},{"path":"banding.html","id":"banding","chapter":"1 Banding","heading":"1 Banding","text":"now unexplained banding phenomenon shows cases lower elevation scans Dutch radars. appears result something going dual-PRF scans, especially vicinity clutter sources sea (wind parks, ships).","code":""},{"path":"banding.html","id":"the-problem","chapter":"1 Banding","heading":"1.1 The problem","text":"Let’s load example scan calculate RBC PPI shows issue clearly.pvol create \\((r, )\\) range-azimuth plot 7 lowest scans, issue visible higher elevations scan. Though may still occur , due elevations highest scans clear effect PPIs anyways.suggests ’s related dual-PRF scans indeed, common scans Dutch radar, just throw serve important purpose: unambiguous velocities dual-PRF scans highest, VRAD values least likely fold/alias. following scans use dual-PRFs.words, 3 elevations use, two \\(0.3^\\circ\\) scans bird-bath scan \\(90^\\circ\\), ’s option, waste, throw dual-PRF scans .","code":"\npvolfile <- \"data/20201002/NLDHL_pvol_20201002T0550_6234.h5\"\npvol <- read_pvolfile(file = pvolfile, param = \"all\")\nvp <- calculate_vp(pvolfile, verbose = FALSE)\nppi_banding <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")\nplot_banding <- plot(ppi_banding) + ggtitle(\"Original RBC PPI\")\nplot_banding\nelevs <- get_elevation_angles(pvol)\nnr_elevs <- 1:7\nlapply(nr_elevs, function(x) {\n  plot(pvol$scans[[x]], xlim = c(0, 320000)) + \n    ggtitle(paste0(\"Elevation: \", round(elevs[x], 2),\n                   \"; High prf: \", pvol$scans[[x]]$attributes$how$highprf,\n                   \"; Low prf: \", pvol$scans[[x]]$attributes$how$lowprf))\n})\nget_elevation_angles(pvol)[which(sapply(pvol$scans, function(x) x$attributes$how$highprf != 0 & x$attributes$how$lowprf != 0))]##  [1]  0.3  0.8  1.2  2.0  2.8  4.5  6.0  8.0 10.0 12.0 15.0 20.0 25.0"},{"path":"banding.html","id":"solution","chapter":"1 Banding","heading":"1.2 Solution","text":"can plot parameters single elevation scan see possibilities filter banding issue .seems RHOHV DPR sufficient filter majority areas banding pattern occurs. fact, standard rain filter de-speckling (using RHOHV > 0.95 DPR < -12) probably unintentionally done . can apply filter plot results .Now recalculate RBC (right) compare results initial version banding (left).’s much better already.Finally, example moment Herwijnen radar shows substantial banding (left), moment filtered quite bit (right). load following pvol: NLHRW_pvol_20201002T1350_6356.h5.Obviously rain-filtering needs work, particular smoothing despeckling, approaches improve precipitation filtering presumably automatically improve filtering banding issue well.","code":"\npvol <- calculate_param(pvol, \n                        ZDRL = 10 ** ((DBZH - DBZV) /10),\n                        DPR = 10 * log10((ZDRL + 1 - 2 * ZDRL^0.5 * RHOHV) / (ZDRL + 1 + 2 * ZDRL^ 0.5 * RHOHV)))\nlapply(c(\"DBZH\", \"VRADH\", \"RHOHV\", \"DPR\"), function(x) plot(pvol$scans[[1]], xlim = c(0, 200000), param = x))\npvol <- calculate_param(pvol, RAIN = RHOHV >= 0.95, DBZHF = DBZH)\n\npvol$scans <- lapply(pvol$scans, function(x) {\n  dbzh <- x$params[[\"DBZH\"]]\n  rhohv <- x$params[[\"RHOHV\"]]\n  dpr <- x$params[[\"DPR\"]]\n  dbzh[rhohv >= 0.95] <- NA\n  dbzh[dpr < -12] <- NA\n  x$params[[\"DBZHF\"]] <- dbzh\n  return(x)\n})\n\nlapply(nr_elevs, function(x) {\n  plot(pvol$scans[[x]], xlim = c(0, 320000), param = \"DBZHF\") + \n    ggtitle(paste0(\"Elevation: \", round(elevs[x], 2),\n                   \"; High prf: \", pvol$scans[[x]]$attributes$how$highprf,\n                   \"; Low prf: \", pvol$scans[[x]]$attributes$how$lowprf))\n})\npvol_filtered <- calculate_param(pvol, DBZH = DBZHF)\nppi_nobanding <- integrate_to_ppi(pvol_filtered, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500)\nplot_nobanding <- plot(ppi_nobanding) + ggtitle(\"Filtered RBC PPI\")\nplot_banding + plot_nobanding + plot_layout(guides = \"collect\")"},{"path":"simple-rain-segmentation.html","id":"simple-rain-segmentation","chapter":"2 Simple rain segmentation","heading":"2 Simple rain segmentation","text":"Classifying rain using RHOHV DPR (depolarization ratio, Kilambi et al.) gets us way elegant filtering procedure rain, issue remains edges rain clouds, dual-pol products derivatives less performant. , try image processing technique can help improve rain segmentation bit .","code":""},{"path":"simple-rain-segmentation.html","id":"problem","chapter":"2 Simple rain segmentation","heading":"2.1 Problem","text":"Let’s load pvol rain show looks like range-bias correction.","code":"\npvolfile <- \"data/20201002/NLHRW_pvol_20201002T1205_6356.h5\"\npvol <- read_pvolfile(file = pvolfile, param = \"all\")\nvp <- calculate_vp(pvolfile, verbose = FALSE)\nppi_rainy <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")\nplot(ppi_rainy)"},{"path":"simple-rain-segmentation.html","id":"solution-1","chapter":"2 Simple rain segmentation","heading":"2.2 Solution","text":"’s clearly lot rain scan. Now, can filter using depolarization ratio, requires additional steps:reasons radar rangegates full combination DBZH, DBZV RHOHV contained within, means pixels either ZDR calculated, RHOHV available calculation DPR.edges rain clouds necessarily well identified DPR (RHOHV matter), need apply buffering/smoothing improve .","code":""},{"path":"simple-rain-segmentation.html","id":"filter-pixels-without-dual-pol-measurements","chapter":"2 Simple rain segmentation","heading":"2.2.1 Filter pixels without dual-pol measurements","text":"First, let’s make plot pixels lose filter pixels can calculate DPR , means DBZV RHOHV must available.can also plot difference, make difference 0 transparent better see PPI pixels changed dramatically, plot differences histogram.PPI histogram suggest VIR differences occur regions already high reflectivities, particular PPI must mostly rain. filtering pixels doesn’t hurt much. Presumably applies across board, ’ll require investigation. Nevertheless, now assume filtering pixels presence DBZH seems reasonable.","code":"\npvol_original <- pvol  # Let's keep the original pvol for comparison\n\npvol <- calculate_param(pvol, \n                        ZDRL = 10 ** ((DBZH - DBZV) /10),\n                        DPR = 10 * log10((ZDRL + 1 - 2 * ZDRL^0.5 * RHOHV) / (ZDRL + 1 + 2 * ZDRL^ 0.5 * RHOHV)),\n                        DBZHO = DBZH)\n\npvol$scans <- lapply(pvol$scans, function(x) {\n  x$params[[\"DBZH\"]][is.na(x$params[[\"DPR\"]])] <- NA\n  x$params[[\"RHOHV\"]][is.na(x$params[[\"DBZH\"]])] <- NA\n  return(x)\n})\n\nppiplot_rainy <- plot(ppi_rainy) + ggtitle(\"Original RBC PPI\")\nppi_dualpol <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")\nppiplot_dualpol <- plot(ppi_dualpol) + ggtitle(\"Dual-pol available RBC PPI\")\n\nppiplot_rainy + ppiplot_dualpol + plot_layout(guides = \"collect\")\nppi_difference <- ppi_dualpol\nppi_difference$data$VIR <- ppi_rainy$data$VIR - ppi_dualpol$data$VIR\nppi_difference$data$VIR[ppi_difference$data$VIR == 0] <- NA\n\nppiplot_difference <- plot(ppi_difference) + \n  scale_fill_viridis_c(trans = \"log10\") +\n  labs(fill = \"VIR diff\") +\n  # guides(fill = guide_legend(title = \"VIR diff\")) +\n  ggtitle(\"Original pixels - pixels with DPR\")\n\nas.data.frame(ppi_difference$data) %>%\n  drop_na() %>%\n  filter(VIR < 1e5) %>%\n  ggplot() +\n  geom_histogram(aes(x = VIR)) + \n  scale_x_continuous(trans = \"log10\") +\n  labs(x = \"VIR diff\") -> plot_difference\n\nppiplot_difference + plot_difference"},{"path":"simple-rain-segmentation.html","id":"image-processing","chapter":"2 Simple rain segmentation","heading":"2.2.2 Image processing","text":"start illustrating approach single scan. use DPR main masking methodology, though ’s possible extend technique include RHOHV, combined approach may perform better. plot \\((r,)\\) plot white pixels classified rain (dpr < -12), black pixels .shows lot pixels, especially close radar (lower x-values), get flagged rain DPR value. Kilambi et al. recommend despeckling. Let’s use median-filter apply despeckling.already looks better, now ‘blurred’ regions larger pixels. assume true rain occurs mostly larger areas, can compute contiguous areas flagged precipitation, calculate surface (number pixels within) filter based minimum number pixels. case, classify rain rain covers least 50 pixels/rangegates.Now, ’s chance miss pixels left right, conservatively filter rain, buffer areas bit. , ’ll calculate euclidean distance non-rain rain pixels distance < 5 units, ’ll flag pixels rain well.can now check looks like apply masking approach scans polar volumes. First plot single scan ’ve cleaned far.Except continuing presence interference pattern, possibly filtering areas ground clutter wind parks, see much cleaner rain filtering buffered threshold filter.Now let’s apply full pvol., calculate RBC plot resulting PPI.first sight RBC PPI may look quite messy filtering, overall approach seems work quite well:edges rain clouds removed quite well, mostly exception > 80km radar, probably mostly due dual-pol measurements working well anymore distances anyways.can still apply post-processing RBC PPIs, example filtering pixels high values VIR birds. simply despeckle, calculate median value across whole image.now applied single buffering procedure scans elevations, possibly tweaked elevation. higher elevations, can probably filter quite agressively, especially also include altitude ground filtering approach.Many speckles visible necessarily rain, already present original RBC PPI, approach definitely worsen issue much.Finally, outcome range-bias correction projection integrated reflections cartesian grid, consider vertically stack rain segmentations projecting slant ground range using combined mask filter entire regions covered rain. assumes rain clouds always stretch vertically along full altitude range covered radar, may realistic, create clean interpretable RBC PPI acceptable trade-.","code":"\nscan.dpr <- as.cimg(pvol$scans[[1]]$params[[\"DPR\"]])\n\n(scan.dpr <= -12 & !is.na(scan.dpr)) %>%\n  plot()\n(scan.dpr <= -12 & !is.na(scan.dpr)) %>%\n  medianblur(4) %>%\n  threshold(0) ->\n  despeckled\n\ndespeckled %>% plot()\ndespeckled %>%\n  split_connected() %>%\n  purrr::keep(~ sum(.) > 50) %>%\n  parany() -> areafilter\n\nareafilter %>% plot()\nareafilter %>%\n  distance_transform(1, metric = 2) %>%\n  threshold(5) -> buffered\n\n(-buffered) %>%\n  plot()\npvol_buffer <- pvol\npvol_thresh <- pvol\n\npvol_buffer$scans[[1]]$params$DBZH[!as.matrix(buffered)] <- NA\npvol_thresh$scans[[1]]$params$DBZH[pvol_thresh$scans[[1]]$params$DPR < -12 | pvol_thresh$scans[[1]]$params$RHOHV >= 0.95] <- NA\n\n(plot(pvol_original$scans[[1]], xlim = c(0, 180000)) + ggtitle(\"Original PVOL\")) /\n  (plot(pvol_thresh$scans[[1]], xlim = c(0, 180000)) + ggtitle(\"Simple threshold filter\")) /\n  (plot(pvol_buffer$scans[[1]], xlim = c(0, 180000)) + ggtitle(\"Buffered threshold filter\"))\nrainfilter <- function(scan) {\n  if (scan$geo$elangle < 90) {\n    dpr <- as.cimg(scan$params[[\"DPR\"]])\n    (dpr <= -12 & !is.na(dpr)) %>%\n      medianblur(4) %>%  # Works adequate for de-speckling\n      threshold(0) %>%  # Set all pixels that have been affected by median blurring to 1, rest to 0\n      split_connected() %>%  # Split image in contiguous areas classified as rain\n      purrr::keep(~ sum(.) > 50) %>%  # Only keep contiguous rain areas if area is > 50 pixels\n      parany() -> contiguous  # Merge to 1 image again\n    if (!is.null(contiguous)) {  # Only buffer if any rain areas of > 50 pixels are retained\n      contiguous %>%\n        distance_transform(1, 2) %>%  # Calculate Euclidean distance (2nd argument) to pixels classified as 1\n        threshold(5) -> dpr_filter\n      \n      dpr_filter <- -dpr_filter\n      scan$params$DBZH[!as.matrix(dpr_filter)] <- NA \n    }\n  }\n  return(scan)\n}\n\npvol$scans <- lapply(pvol$scans, function(x) {\n  x$params[[\"DBZH\"]][is.na(x$params[[\"DPR\"]])] <- NA\n  # x$params[[\"DBZH\"]][x$params[[\"RHOHV\"]] >= 0.95] <- NA\n  # x$params[[\"DBZH\"]][x$params[[\"DPR\"]] < -12] <- NA\n  x <- rainfilter(x)\n  return(x)\n})\nppi_buffered <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")\nppiplot_buffered <- plot(ppi_buffered) + ggtitle(\"Buffered rain filtering\")\n\n(ppiplot_rainy + ggtitle(\"Original RBC PPI\")) + ppiplot_buffered + plot_layout(guides = \"collect\")"},{"path":"rain-stacking.html","id":"rain-stacking","chapter":"3 Rain stacking","heading":"3 Rain stacking","text":"follow similar approach outlined rain segmentation approach, time ‘stack’ segmented across different elevation scans, essence filter scans rain using calculated maximum spatial extent rain cloud.","code":""},{"path":"rain-stacking.html","id":"problem-1","chapter":"3 Rain stacking","heading":"3.1 Problem","text":"Let’s load pvol rain show looks like range-bias correction.can see rain removed, speckles remain areas mostly clear precipitation.","code":"\nclassify_rain <- function(scan) {\n  if (scan$geo$elangle < 90) {\n    dpr <- as.cimg(scan$params[[\"DPR\"]])\n    (dpr <= -12 & !is.na(dpr)) %>%\n      medianblur(4) %>%  # Works adequate for de-speckling\n      threshold(0) %>%  # Set all pixels that have been affected by median blurring to 1, rest to 0\n      split_connected() %>%  # Split image in contiguous areas classified as rain\n      purrr::keep(~ sum(.) > 100) %>%  # Only keep contiguous rain areas if area is > 50 pixels\n      parany() -> contiguous  # Merge to 1 image again\n    if (!is.null(contiguous)) {  # Only buffer if any rain areas of > 50 pixels are retained\n      contiguous %>%\n        distance_transform(1, 2) %>%  # Calculate Euclidean distance (2nd argument) to pixels classified as 1\n        threshold(5) -> dpr_filter\n      \n      dpr_filter <- as.matrix(-dpr_filter)\n      dpr_filter[dpr_filter == -1] <- NA\n      scan$params$RAIN <- dpr_filter\n      class(scan$params$RAIN) <- c(\"param\", \"matrix\")\n    }\n  }\n  return(scan)\n}\n\npvol$scans <- lapply(pvol$scans, function(x) {\n  x$params[[\"DBZH\"]][is.na(x$params[[\"DPR\"]])] <- NA\n  x <- classify_rain(x)\n  return(x)\n})\n\nranges <- lapply(pvol$scans[1:15], function(x) {\n  data <- do.call(function(y) x$params[[y]], list(\"RAIN\"))\n  class(data) <- \"matrix\"\n  range <- (1:dim(data)[1]) * x$geo$rscale\n  groundrange <- round(beam_distance(range, x$geo$elangle))\n  list(raster::flip(raster::raster(t(data), ymn = 0, ymx = 360, xmn = 0, xmx = max(range)), direction = \"y\"),\n       raster::flip(raster::raster(t(data), ymn = 0, ymx = 360, xmn = 0, xmx = max(groundrange)), direction = \"y\"))\n})\n\nget_largest_extent <- function(rasters) {\n  # https://gis.stackexchange.com/a/287081\n  extents <- sapply(rasters, FUN = function(x) {\n    raster::extent(x)\n  })\n  r <- raster(ext = extents[[1]], nrows = rasters[[1]]@nrows, ncols = rasters[[1]]@ncols)\n  max_extent <- sapply(extents, FUN = function(x) {\n    r <<- raster::extend(r, x)\n  })\n  raster::extent(r)\n}\n\ntarget_extent <- get_largest_extent(lapply(ranges, function(x) x[[2]]))\n\ngroundranges_points <- lapply(ranges, function(x) rasterToPoints(x[[2]], spatial = TRUE))\n\ngroundranges_coverage <- mapply(function(x, i) {\n  r <- x[[2]]\n  r[!is.na(r)] <- i\n  rasterToPoints(r, spatial = TRUE)\n}, ranges, get_elevation_angles(pvol)[1:15])\n\ngr <- do.call(rbind, groundranges_points)\ngr_cov <- do.call(rbind, groundranges_coverage)\ng <- rasterize(gr, raster(target_extent, res = c(500, 1)), \"layer\", fun = \"count\")\n# g_cov <- rasterize(gr_cov, raster(target_extent, res = c(500, 1)), \"layer\", fun = \"sum\")\ng_cov <- rasterize(gr_cov, raster(target_extent, res = c(500, 1)), \"layer\", fun = mean, na.rm = TRUE)\ng <- g_cov\n\ng_dist <- as.cimg(g_cov)\n\npvol$scans[1:15] <- mapply(function(scan, rainmask) {\n  cropped <- crop(g, rainmask[[2]])\n  resampled <- resample(cropped, rainmask[[1]])\n  \n  scan$params$RAINSTACK <- t(as.matrix(flip(resampled, \"y\")))\n  class(scan$params$RAINSTACK) <- c(\"param\", \"matrix\")\n  attributes(scan$params$RAINSTACK) <- attributes(scan$params$DBZH)\n  attr(scan$params$RAINSTACK, \"param\") <- \"RAINSTACK\"\n  return(scan)\n}, pvol$scans[1:15], ranges, SIMPLIFY = FALSE)\n\npvol$scans <- lapply(pvol$scans, function(x) {\n  x$params[[\"DBZH\"]][!is.na(x$params[[\"RAINSTACK\"]])] <- NA\n  return(x)\n})\n\nppi_filtered <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")## Warning in integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim =\n## c(-180000, : ignoring 90 degree birdbath scan\nppi_rainmask <- project_as_ppi(get_param(pvol$scans[[1]], \"RAINSTACK\"), grid_size = 500, range_max = 180000)\n# (plot(ppi_filtered)) + plot(ppi_rainmask) +\n(ppiplot_rainy + (plot(ppi_buffered) + ggtitle(\" + Buffered rain filtering\"))) /\n((plot(ppi_filtered) + ggtitle(\" + Rain stack filter\")) + (plot(ppi_rainmask) + ggtitle(\"Rain stack\"))) + \n  plot_layout(guides = \"collect\") + plot_annotation(title = basename(pvolfile))"},{"path":"rain-visualisation.html","id":"rain-visualisation","chapter":"4 Rain visualisation","heading":"4 Rain visualisation","text":"previous approaches segmentation perhaps, unintentionally, resulted methodology thoroughly clean RBC PPIs rain, necessarily useful visualisation. Now, instead, ’ll try approach simply focuses visually distinguishing rain sources reflectivity RBC PPIs.Let’s plot RBC PPI.\nDBZH DPR across 5 scans.Now can use DPR visualize rain .plot visualization.","code":"\npvolfile <- \"data/20201002/NLHRW_pvol_20201002T1205_6356.h5\"\n# pvolfile <- \"data/20201001/NLHRW_pvol_20201001T2040_6356.h5\"\npvolfile <- \"data/20201001/NLHRW_pvol_20201001T1740_6356.h5\"\n\npvol <- read_pvolfile(file = pvolfile, param = \"all\")\npvol <- calculate_param(pvol, \n                        ZDRL = 10 ** ((DBZH - DBZV) /10),\n                        DPR = 10 * log10((ZDRL + 1 - 2 * ZDRL^0.5 * RHOHV) / (ZDRL + 1 + 2 * ZDRL^ 0.5 * RHOHV)))\nvp <- calculate_vp(pvolfile, verbose = FALSE)\nppi_rainy <- integrate_to_ppi(pvol, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")\nplot(ppi_rainy)\npvol$scans <- lapply(pvol$scans, function(x) {\n  x$params[[\"DBZH\"]][is.na(x$params[[\"DPR\"]])] <- NA\n  return(x)\n})\nlapply(pvol$scans[1:5], function(x) {\n  dbzh <- get_param(x, \"DBZH\")\n  dpr <- get_param(x, \"DPR\")\n  vradh <- get_param(x, \"VRADH\")\n  ppidbzh <- project_as_ppi(dbzh, grid_size = 500, range_max = 150000)\n  ppidpr <- project_as_ppi(dpr, grid_size = 500, range_max = 150000)\n  # ppivradh <- project_as_ppi(vradh, grid_size = 500, range_max = 150000)\n  plot(ppidbzh) + plot(ppidpr) # + plot(ppivradh)\n})## [[1]]\n## \n## [[2]]\n## \n## [[3]]\n## \n## [[4]]\n## \n## [[5]]\nmasks <- lapply(pvol$scans[1:15], function(x) {\n  ppi <- project_as_ppi(get_param(x, \"DPR\"), grid_size = 500, range_max = 180000)\n  \n  if (ppi$geo$elangle < 90) {\n    dpr <- as.cimg(as.matrix(ppi$data))\n    (dpr <= -12 & !is.na(dpr)) %>%\n      clean(4) %>%  # Remove speckles by shrinking then growing using a 4px radius\n      fill(10) -> filled\n    \n    if (sum(filled) > 0) {\n      filled %>%\n        split_connected() %>%  # Split image in contiguous areas classified as rain\n        purrr::keep(~ sum(.) > 100) %>%  # Only keep contiguous rain areas if area is > 100 pixels\n        parany() -> contiguous  # Merge to 1 image again\n    }\n    if (exists(\"contiguous\") && !is.null(contiguous)) {  # Only buffer if any rain areas of > 50 pixels are retained\n      contiguous %>%\n        distance_transform(1, 2) %>%  # Calculate Euclidean distance (2nd argument) to pixels classified as 1\n        threshold(5) -> dpr_mask\n      \n      dpr_mask %>%\n        distance_transform(1, 2) -> dist_mask\n      \n      dpr_mask <- -dpr_mask\n      \n      m <- as.matrix(dpr_mask)\n      m[m == 0] <- 1\n      m[m == -1] <- NA\n      \n      d <- as.matrix(dist_mask)\n      d[d == 0] <- NA\n      return(list(m, d))\n    } else {\n      o <- matrix(nrow = ppi$data@grid@cells.dim[1], ncol = ppi$data@grid@cells.dim[2])\n      return(list(o, o))\n    }\n  }\n})\n\nrain_elevations <- simplify2array(lapply(masks, function(x) x[[1]]))\nrain_distances <- simplify2array(lapply(masks, function(x) x[[2]]))\nrain_elevations <- apply(rain_elevations, c(1, 2), sum, na.rm = TRUE)\nrain_elevations[rain_elevations <= 1] <- NA\nrain_distances <- apply(rain_distances, c(1, 2), sum, na.rm = TRUE)\nrain_distances[rain_distances == 0] <- NA\n\nppi_rainy$data$rain_distance <- as.vector(rain_distances)\nppi_rainy$data$rain_elevations <- as.vector(rain_elevations)\ndata <- do.call(function(y) ppi_rainy$data[y], list(c(\"VIR\", \"rain_elevations\")))\ndata <- raster::as.data.frame(stack(data), xy = T)\nbbox <- coord_fixed(xlim = c(-160000, 160000), ylim = c(-160000, 160000))\nzlim = c(0, 5000)\nindex <- which(data[, 3] < zlim[1])\nif (length(index) > 0) {\n  data[index, 3] <- zlim[1]\n}\nindex <- which(data[, 3] > zlim[2])\nif (length(index) > 0) {\n  data[index, 3] <- zlim[2]\n}\n\nggplot(data = data) +\n  geom_raster(aes(x = x, y = y, fill = VIR)) +\n  scale_fill_viridis_c(trans = \"log10\", na.value = \"transparent\", option = \"plasma\") +\n  new_scale_fill() +\n  geom_raster(aes(x = x, y = y, fill = rain_elevations, alpha = rain_elevations)) +\n  # scale_fill_continuous(na.value = \"transparent\") +\n  scale_fill_gradient(na.value = \"transparent\", low = \"white\", high = \"#7fb4ff\") +\n  scale_alpha_continuous(range = c(0.9, 1)) +\n  theme_bw() +\n  bbox## Warning: Transformation introduced infinite values in discrete y-axis\nsource(\"R/comp_ppi.R\")\nhrw_ppis <- Sys.glob(file.path(\"data/processed/final-ppis\", \"*NL62*\"))\ndhl_ppis <- Sys.glob(file.path(\"data/processed/final-ppis\", \"*NL61*\"))\n\ngenerate_composites <- function(hrw_ppis, dhl_ppis, res, maxrange) {\n  # Make a new empty PPI to store all composites in\n  template_ppi <- readRDS(hrw_ppis[1])\n  all <- template_ppi$data@data %>%\n    filter(row_number() == 0)\n  \n  basemap <- NULL\n  \n  for (i in seq_along(hrw_ppis)) {\n    ppi_hrw <- readRDS(hrw_ppis[i])\n    ppi_dhl <- readRDS(dhl_ppis[i])\n    \n    # Set all columns to NA if further than maxrange from radar\n    ppi_hrw$data@data[ppi_hrw$data@data$dist_radar > maxrange, ] <- NA\n    ppi_dhl$data@data[ppi_dhl$data@data$dist_radar > maxrange, ] <- NA\n    \n    params <- c(\"VIR\", \"VID\", \"R\", \"overlap\", \"eta_sum\", \"eta_sum_expected\", \"dist_radar\", \"class\",\n                \"urban\", \"agricultural\", \"semiopen\", \"forests\", \"wetlands\", \"waterbodies\", \"dist_urban\", \"human_pop\",\n                \"wb_area_id\", \"wb_area_nr\", \"ptt_route\", \"wb_area_ha\", \"wb_total_biomass\", \"ptt_total_biomass\", \"total_biomass\", \n                \"wb_weighted_mean_weight\", \"ptt_weighted_mean_weight\", \"weighted_mean_weight\")\n    # All mean methods except for factors and urban area (set to max), because we want to strictly filter out fireworks\n    methods <- c(\"mean\", \"mean\", \"mean\", \"mean\", \"mean\", \"mean\", \"min\", \"min\",\n                 \"max\", \"mean\", \"mean\", \"mean\", \"mean\", \"mean\", \"mean\", \"mean\", \n                 \"factor\", \"factor\", \"factor\", \"factor\", \"mean\", \"mean\", \"mean\",\n                 \"mean\", \"mean\", \"mean\")\n    cppi <- comp_ppi(list(ppi_hrw, ppi_dhl), param = params, method = methods, res = c(res, res), coverage = \"count\")\n    \n    # Set rain and background pixels to NA\n    cppi$data$VIR[cppi$data$class < 2] <- NA\n    \n    # Add coordinates\n    coords_cppi <- raster::coordinates(cppi$data)\n    cppi$data$x <- coords_cppi[, 1]\n    cppi$data$y <- coords_cppi[, 2]\n    \n    # Add pixel ID\n    cppi$data@data %>%\n      mutate(pixel = row_number()) -> cppi$data@data\n    \n    # Solve different factors\n    solve_factors <- function(x) {\n      r <- x[1]\n      if (is.na(x[1]) && is.na(x[2])) { r <- NA }\n      if (is.na(x[1]) && !is.na(x[2])) { r <- x[2] }\n      if (!is.na(x[1]) && is.na(x[2])) { r <- x[1] }\n      if (!is.na(x[1]) && !is.na(x[2])) {\n        if (x[1] != x[2]) {\n          r <- NA\n        } else {\n          r <- x[1]\n        }\n      }\n      r\n    }\n    \n    for (j in which(methods == \"factor\")) {\n      cppi$data@data[params[j]] <- apply(cppi$data@data[params[j]], 1, solve_factors)\n    }\n    \n    saveRDS(cppi, file = paste(\"data/processed/composite-ppis/\", res, \"m/\", strftime(ppi_hrw$datetime, format = \"%Y%m%d%H%M\"), \".RDS\", sep = \"\"))\n    \n    cppi$data@data %>%\n      mutate(datetime = as.POSIXct(ppi_hrw$datetime)) %>%\n      bind_rows(all) -> all\n    \n    if (i == 1) {\n      basemap <- download_basemap(cppi, alpha = 0.3)\n    }\n    \n    cppi$data$VIR <- log10(cppi$data$VIR)\n    cppi$data$VIR[is.na(cppi$data$VIR)] <- 0\n    \n    bioRad::map(cppi, map = basemap, radar_size = 1, xlim = c(3.1, 6.8), ylim = c(51, 54), zlim = c(0, 4.5),\n                palette = viridis(256, option = \"viridis\", alpha = 0.6)) +\n      labs(title = \"Fireworks NYE 2017-2018\",\n           subtitle = paste(ppi_hrw$datetime, ' UTC', sep = \"\"))\n\n    ggsave(paste(\"data/plots/vir-ppis/\", res, \"m/\", strftime(ppi_hrw$datetime, format = \"%Y%m%d%H%M\"), \".png\", sep = \"\"))\n  }\n  \n  saveRDS(all, file = paste(\"data/processed/all_\", res, \"m.RDS\", sep = \"\"))\n}\n\n# Somehow this often hangs despite ample memory available, in which case better executed serially.\n# r <- parallel::mclapply(c(500, 1000, 2000), function(x) { generate_composites(hrw_ppis, dhl_ppis, res = x, maxrange = 66000)},\n#                         mc.cores = 3, mc.preschedule = FALSE)\nr <- parallel::mclapply(c(1000, 2000), function(x) { generate_composites(hrw_ppis, dhl_ppis, res = x, maxrange = 66000)},\n                        mc.cores = 3, mc.preschedule = FALSE)"},{"path":"em-interference.html","id":"em-interference","chapter":"5 EM Interference","heading":"5 EM Interference","text":"","code":"\npvolfile <- \"data/20201002/NLHRW_pvol_20201002T1205_6356.h5\"\n# pvolfile <- \"data/20201001/NLHRW_pvol_20201001T0955_6356.h5\"\n# pvolfile <- \"data/20201001/NLHRW_pvol_20201001T0000_6356.h5\"\npvol <- read_pvolfile(file = pvolfile, param = \"all\")\npvol <- calculate_param(pvol, \n                        ZDRL = 10 ** ((DBZH - DBZV) /10),\n                        DPR = 10 * log10((ZDRL + 1 - 2 * ZDRL^0.5 * RHOHV) / (ZDRL + 1 + 2 * ZDRL^ 0.5 * RHOHV)))## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\n\n## Warning in eval(nn <- (calc[[i]]), x$params): NaNs produced\nppi <- project_as_ppi(pvol$scans[[1]], range_max = 180000, grid_size = 500)\nplot(ppi)\nplot(pvol$scans[[1]], xlim = c(0, 180000))\nplot(pvol$scans[[1]], xlim = c(0, 180000), ylim = c(70, 110))\nrange_coverage <- function(scan) {\n  s <- as.matrix(scan$params$DBZH)\n  class(s) <- \"matrix\"\n  \n  hasvalue <- s\n  hasvalue[!is.na(s)] <- 1\n  coverage <- colSums(hasvalue, na.rm = TRUE)\n  coverage / dim(s)[1]\n}\n\nhist(range_coverage(pvol$scans[[1]]))\ncalc_linearity <- function(scan) {\n  s <- as.matrix(scan$params$DBZH)\n  class(s) <- \"matrix\"\n\n  apply(s, 2, function(d) {\n    nearestbin <- round(50000 / scan$geo$rscale)\n    r <- nearestbin:dim(s)[1]\n    dbzh <- d[r]\n    data <- data.frame(r = r, dbzh = dbzh) %>% drop_na()\n    if (nrow(data) > 20) {\n      m <- lm(dbzh ~ r, data = data)\n      if (coef(m)[2] > 0) {  # Only return non-NA if slope is positive\n        summary(m)$r.squared\n      } else {\n        NA\n      }\n    } else {\n      NA\n    }\n  })\n}\nhist(calc_linearity(pvol$scans[[1]]))\nclassified_em <- which(calc_linearity(pvol$scans[[1]]) > 0.75 & range_coverage(pvol$scans[[1]]) > 0.75)\nclassified_em <- sort(unique(c(classified_em - c(1), classified_em, classified_em + c(1))))\nclassified_em##  [1]  72  73  74  75  76  77  90  91  92  99 100 101 102 103\ninterpolate_em <- function(scan, beams) {\n  s <- as.matrix(scan$params$DBZH)\n  class(s) <- \"matrix\"\n  \n  consecutive_beams <- split(beams, cumsum(c(1, diff(beams) != 1)))\n  \n  for (cb in consecutive_beams) {\n    extract_beams <- c(min(cb) - 1, cb, max(cb) + 1)\n    m <- s[, extract_beams]\n    m[is.na(m)] <- -9999\n    m[, 2:(length(extract_beams) - 1)] <- NA\n    x <- 1:dim(m)[1]  # Ranges\n    y <- c(1, length(extract_beams))  # Azimuths\n    z <- t(m[x, y])\n    xp <- x\n    yp <- 2:(length(extract_beams) - 1)\n    ip <- expand.grid(x, yp)\n    mi <- matrix(interp2(x, y, z, ip[, 1], ip[, 2], method = \"nearest\"), nrow = length(x))\n    mi[mi == -9999] <- NA\n    # Now that we have interpolated NA values using nearest-neighbor, we can interpolate reflectivity\n    ip2 <- which(!is.na(mi), arr.ind = TRUE)\n    mp <- interp2(x, y, z, ip2[, 1], ip2[, 2], method = \"linear\")\n    mi[cbind(ip2[, 1], ip2[, 2])] <- mp\n    s[, cb] <- mi\n  }\n  \n  scan$params$DBZH <- s\n  return(scan)\n}\nplot(interpolate_em(pvol$scans[[1]], classified_em))\np <- pvol\np$scans <- lapply(p$scans, function(x) {\n  classified_em <- which(calc_linearity(x) > 0.75 & range_coverage(x) > 0.75)\n  classified_em <- sort(unique(c(classified_em - c(1), classified_em, classified_em + c(1))))\n  print(classified_em)\n  if (length(classified_em) > 0) {\n    x <- interpolate_em(x, classified_em)\n  }\n  x\n})##  [1]  72  73  74  75  76  77  90  91  92  99 100 101 102 103\n## [1]  73  74  75  99 100 101 102 103\n##  [1]  72  73  74  75  90  91  92  99 100 101 102 103 104\n## numeric(0)\n## [1] 100 101 102 103\n## numeric(0)\n## numeric(0)\n## numeric(0)\n## [1] 95 96 97\n## numeric(0)\n## numeric(0)\n## numeric(0)\n## numeric(0)\n## numeric(0)\n## numeric(0)\n## numeric(0)\nplot(project_as_ppi(p$scans[[4]], grid_size = 500, range_max = 180000))\nvp <- calculate_vp(pvolfile, verbose = FALSE)\nppi <- integrate_to_ppi(p, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")## Warning in integrate_to_ppi(p, vp, xlim = c(-180000, 180000), ylim =\n## c(-180000, : ignoring 90 degree birdbath scan\nplot(ppi)\np <- pvol\nidentify_em_interference <- function(pvol) {\n  beams <- lapply(pvol$scans, function(x) {\n    classified_em <- which(calc_linearity(x) > 0.75 & range_coverage(x) > 0.75)\n    classified_em <- sort(unique(c(classified_em - c(1), classified_em, classified_em + c(1))))\n    classified_em\n  })\n  \n  elevs <- round(get_elevation_angles(pvol), 1)\n  \n  beams <- lapply(elevs, function(x) {\n    identical <- which(elevs == x)\n    if (length(identical) > 0) {\n      b <- unique(unlist(beams[identical]))\n    } else {\n      NULL\n    }\n  })\n  beams\n}\nbeams <- identify_em_interference(p)\n\np$scans <- mapply(function(x, y) {\n  if (length(y) > 0) {\n    interpolate_em(x, y)\n  } else {\n    x\n  }\n}, pvol$scans, beams, SIMPLIFY = FALSE)\nppi <- integrate_to_ppi(p, vp, xlim = c(-180000, 180000), ylim = c(-180000, 180000), res = 500, param = \"DBZH\")## Warning in integrate_to_ppi(p, vp, xlim = c(-180000, 180000), ylim =\n## c(-180000, : ignoring 90 degree birdbath scan\nplot(ppi)"}]
